<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Differences: Go make vs. new</title></head><body><article class="page serif"><header><div class="page-header-icon undefined"><img class="icon" src="https://www.notion.so/icons/help-alternate_red.svg"/></div><h1 class="page-title">Differences: Go make vs. new</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-created_by"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedBy"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 10.4229C6.05176 10.4229 4.54785 11.1133 3.83008 11.9131C2.90039 10.9082 2.33301 9.55469 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 9.55469 13.1064 10.9082 12.1699 11.9131C11.4521 11.1133 9.94824 10.4229 8 10.4229ZM8 9.30176C9.32617 9.30859 10.3516 8.18066 10.3516 6.71094C10.3516 5.33008 9.31934 4.18164 8 4.18164C6.6875 4.18164 5.6416 5.33008 5.64844 6.71094C5.65527 8.18066 6.68066 9.28809 8 9.30176Z"></path></svg></span>Created by</th><td><span class="user"><img src="Differences%20Go%20make%20vs%20new%2032cefa368b824d4d917ee187cd40a0e5/IMG_2295.jpg" class="icon user-icon"/>JiaLin Huang</span></td></tr><tr class="property-row property-row-last_edited_time"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedAt"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 13.7383C4.85547 13.7383 2.33301 11.209 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 11.209 11.1445 13.7383 8 13.7383ZM4.54102 8.91211H7.99316C8.30078 8.91211 8.54004 8.67285 8.54004 8.37207V3.8877C8.54004 3.58691 8.30078 3.34766 7.99316 3.34766C7.69238 3.34766 7.45312 3.58691 7.45312 3.8877V7.83203H4.54102C4.2334 7.83203 4.00098 8.06445 4.00098 8.37207C4.00098 8.67285 4.2334 8.91211 4.54102 8.91211Z"></path></svg></span>Last edited</th><td><time>@2024年10月1日 18:23</time></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesMultipleSelect"><path d="M1.91602 4.83789C2.44238 4.83789 2.87305 4.40723 2.87305 3.87402C2.87305 3.34766 2.44238 2.91699 1.91602 2.91699C1.38281 2.91699 0.952148 3.34766 0.952148 3.87402C0.952148 4.40723 1.38281 4.83789 1.91602 4.83789ZM5.1084 4.52344H14.3984C14.7607 4.52344 15.0479 4.23633 15.0479 3.87402C15.0479 3.51172 14.7607 3.22461 14.3984 3.22461H5.1084C4.74609 3.22461 4.45898 3.51172 4.45898 3.87402C4.45898 4.23633 4.74609 4.52344 5.1084 4.52344ZM1.91602 9.03516C2.44238 9.03516 2.87305 8.60449 2.87305 8.07129C2.87305 7.54492 2.44238 7.11426 1.91602 7.11426C1.38281 7.11426 0.952148 7.54492 0.952148 8.07129C0.952148 8.60449 1.38281 9.03516 1.91602 9.03516ZM5.1084 8.7207H14.3984C14.7607 8.7207 15.0479 8.43359 15.0479 8.07129C15.0479 7.70898 14.7607 7.42188 14.3984 7.42188H5.1084C4.74609 7.42188 4.45898 7.70898 4.45898 8.07129C4.45898 8.43359 4.74609 8.7207 5.1084 8.7207ZM1.91602 13.2324C2.44238 13.2324 2.87305 12.8018 2.87305 12.2686C2.87305 11.7422 2.44238 11.3115 1.91602 11.3115C1.38281 11.3115 0.952148 11.7422 0.952148 12.2686C0.952148 12.8018 1.38281 13.2324 1.91602 13.2324ZM5.1084 12.918H14.3984C14.7607 12.918 15.0479 12.6309 15.0479 12.2686C15.0479 11.9062 14.7607 11.6191 14.3984 11.6191H5.1084C4.74609 11.6191 4.45898 11.9062 4.45898 12.2686C4.45898 12.6309 4.74609 12.918 5.1084 12.918Z"></path></svg></span>Tags</th><td></td></tr></tbody></table></header><div class="page-body"><p class="">
</p><h1 class="">TL;DR</h1><p class="">In Go, <code>new</code> and <code>make</code> are both used for memory allocation, but they serve different purposes:</p><ul class="bulleted-list"><li style="list-style-type:disc"><code>new</code> allocates memory and returns a pointer to a zero-valued instance of the specified type.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc"><code>make</code> initializes and returns <strong>slices, maps, and channels only</strong>. It allocates and <mark class="highlight-red"><strong>initializes</strong></mark> the underlying data structures and returns a non-zero value of the specified type.</li></ul><p class="">
</p><h1 class="">new</h1><ul class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>Returns a memory address (pointer)</strong></mark></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Sets the default zero value: empty for strings, 0 for numbers, nil for arrays</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Used for all types</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Go">type Person struct {
  Name    string
  Age     int
  Address string
}

// Basic usage
p := new(Person)

// Usage with initialization
p := &amp;Person{
    Name: &quot;John Doe&quot;,
    Age: 30,
    Address: &quot;123 Main St&quot;,
}</code></pre><h3 class="">Common Mistake</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Go">func main() {
  p := new(map[string]string)
	// This will panic because the map is nil
  test := *p
  test[&quot;foo&quot;] = &quot;bar&quot;
  fmt.Println(test)
}</code></pre><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">make</h1><ul class="bulleted-list"><li style="list-style-type:disc">Allocates and initializes memory</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Only used for slices, maps, and channels</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Returns an initialized (non-zero) value, not a pointer</li></ul><p class="">
</p><h3 class="">Why only for slice, map, and channel?</h3><p class=""><code>make</code> is used exclusively for these types because they require additional initialization beyond simple memory allocation:</p><ol type="1" class="numbered-list" start="1"><li>Slices need an underlying array and metadata (length and capacity).</li></ol><ol type="1" class="numbered-list" start="2"><li>Maps need to initialize the hash table structure.</li></ol><ol type="1" class="numbered-list" start="3"><li>Channels need to set up the communication queue.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Go">
func main() {
	s := make([]int, 10)      // slice with length 10
	m := make(map[string]int) // empty map
	c := make(chan int)       // 0x14000100060

	fmt.Println(s, m, c)

	fmt.Println(&quot;Address result:&quot;)
	fmt.Printf(&quot;%p\n&quot;, &amp;s)
	fmt.Printf(&quot;%p\n&quot;, &amp;m)
	fmt.Printf(&quot;%p\n&quot;, &amp;c)

	fmt.Println(&quot;reflect.ValueOf(m).Pointer() results:&quot;)
	fmt.Printf(&quot;reflect.ValueOf(m).Pointer(): %x\n&quot;, reflect.ValueOf(s).Pointer())
	fmt.Printf(&quot;reflect.ValueOf(m).Pointer(): %x\n&quot;, reflect.ValueOf(m).Pointer())
	fmt.Printf(&quot;reflect.ValueOf(c).Pointer(): %x\n&quot;, reflect.ValueOf(c).Pointer())
}

/*
[0 0 0 0 0 0 0 0 0 0] map[] 0x1400008e060
Address result:
0x140000b6000
0x140000a4018
0x140000a4020
reflect.ValueOf(m).Pointer() results:
reflect.ValueOf(m).Pointer(): 140000b8000
reflect.ValueOf(m).Pointer(): 1400009c0c0
reflect.ValueOf(c).Pointer(): 1400008e060
*/</code></pre><h3 class="">Comparing String() Behavior of Slice, Map, and Channel</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Go">fmt.Println(s, m, c)
// [0 0 0 0 0 0 0 0 0 0] map[] 0x14000098060</code></pre><p class="">You might be confused why <code>c</code> (channel) returns something different from the other two (slice and map). The output for slice and map looks as you&#x27;d expect, but the channel returns a memory address.</p><p class="">This is because the <code>String()</code> method implementation is different for these three types (s, m, c):</p><ol type="1" class="numbered-list" start="1"><li>Slice (s): Directly prints the data content. For example: <code>[1 2 3]</code></li></ol><ol type="1" class="numbered-list" start="2"><li>Map (m): Directly prints the key-value pairs. For example: <code>map[key1:value1 key2:value2]</code></li></ol><ol type="1" class="numbered-list" start="3"><li>Channel (c): Returns the pointer address of the channel. For example: <code>0x1400005e060</code></li></ol><p class="">
</p><p class="">
</p><h3 class="">Understanding Channel Addresses</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Go">fmt.Println(c)
fmt.Printf(&quot;%p\n&quot;, &amp;c)
fmt.Printf(&quot;reflect.ValueOf(c).Pointer(): %v\n&quot;, reflect.ValueOf(c).Pointer())</code></pre><p class="">When discussing channels, we often see three different representations: <code>c</code>, <code>&amp;c</code>, and <code>reflect.ValueOf(c).Pointer()</code>. Let&#x27;s explain these three representations using an analogy:</p><p class="">Imagine we&#x27;re cleaning a room:</p><ol type="1" class="numbered-list" start="1"><li><code>c</code> refers to the abstract concept of &quot;my room&quot;</li></ol><ol type="1" class="numbered-list" start="2"><li><code>&amp;c</code> is the address of my house</li></ol><ol type="1" class="numbered-list" start="3"><li><code>reflect.ValueOf(c).Pointer()</code> is the actual location of the room I&#x27;m going to clean</li></ol><p class="">In code, these three representations look like this:</p><p class="">
</p><h3 class=""><code>s</code> vs. <code>reflect.ValueOf(s).Pointer()</code></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Go">+---------------------+
|        slice s      |
|---------------------|
|  Pointer to array   | ----&gt; +------------------+
|  Length: 10         |       | reflect...       |
|  Capacity: 10       |       |----------------- |
+---------------------+       | 0 | 0 | 0 | 0 | 0|
                              | 0 | 0 | 0 | 0 | 0|
                              +------------------+</code></pre><p class="">
</p><h1 class="">Slices vs. Arrays</h1><table class="simple-table"><tbody><tr><td class="" style="width:155px"><strong>aspect</strong></td><td class="" style="width:292px"><strong>slice</strong></td><td class="" style="width:230.00042724609375px"><strong>array</strong></td></tr><tr><td class="" style="width:155px">length</td><td class="" style="width:292px">dynamic at runtime</td><td class="" style="width:230.00042724609375px">fixed at build time</td></tr><tr><td class="" style="width:155px">Malloc</td><td class="" style="width:292px">Flexible</td><td class="" style="width:230.00042724609375px">Fixed at start</td></tr><tr><td class="" style="width:155px">Access</td><td class="" style="width:292px"><code>[index]</code></td><td class="" style="width:230.00042724609375px"><code>[index]</code></td></tr><tr><td class="" style="width:155px">Initialization</td><td class="" style="width:292px"><code>make([]int, 10)</code></td><td class="" style="width:230.00042724609375px"><code>a := [3]int{1, 2, 3}</code></td></tr><tr><td class="" style="width:155px">Type</td><td class="" style="width:292px">Can be different, e.g., <code>[]interface{}{1, &quot;hello&quot;, 3.14, true}</code></td><td class="" style="width:230.00042724609375px">Fixed, e.g., <code>[3]int</code></td></tr><tr><td class="" style="width:155px">copy behavior</td><td class="" style="width:292px">New copy</td><td class="" style="width:230.00042724609375px">Share reference</td></tr></tbody></table><h3 class="">Slice Growth Analogy</h3><p class="">When a slice needs to grow beyond its current capacity, Go creates a new underlying array in a different memory location, rather than expanding the existing one. This is similar to:<br/><br/><strong>When your family grows, instead of building a small extension next to your house, you move to an entirely new, larger house.</strong> This new house can accommodate all family members, while the old house is left behind.</p><p class="">
</p><p class="">
</p><p class=""><a href="https://stackoverflow.com/questions/36706843/how-to-get-the-underlying-array-of-a-slice-in-go">https://stackoverflow.com/questions/36706843/how-to-get-the-underlying-array-of-a-slice-in-go</a></p><p class=""><a href="https://go.dev/blog/slices-intro">https://go.dev/blog/slices-intro</a></p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body>