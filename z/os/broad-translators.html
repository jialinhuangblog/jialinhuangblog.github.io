<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Broad Translators</title></head><body><article class="page serif"><header><div class="page-header-icon undefined"><img class="icon" src="https://www.notion.so/icons/robot_purple.svg"/></div><h1 class="page-title">Broad Translators</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-created_by"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedBy"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 10.4229C6.05176 10.4229 4.54785 11.1133 3.83008 11.9131C2.90039 10.9082 2.33301 9.55469 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 9.55469 13.1064 10.9082 12.1699 11.9131C11.4521 11.1133 9.94824 10.4229 8 10.4229ZM8 9.30176C9.32617 9.30859 10.3516 8.18066 10.3516 6.71094C10.3516 5.33008 9.31934 4.18164 8 4.18164C6.6875 4.18164 5.6416 5.33008 5.64844 6.71094C5.65527 8.18066 6.68066 9.28809 8 9.30176Z"></path></svg></span>Created by</th><td><span class="user"><img src="Broad%20Translators%201066cd51990d80eaad73dc182b9ead1c/IMG_2295.jpg" class="icon user-icon"/>JiaLin Huang</span></td></tr><tr class="property-row property-row-last_edited_time"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedAt"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 13.7383C4.85547 13.7383 2.33301 11.209 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 11.209 11.1445 13.7383 8 13.7383ZM4.54102 8.91211H7.99316C8.30078 8.91211 8.54004 8.67285 8.54004 8.37207V3.8877C8.54004 3.58691 8.30078 3.34766 7.99316 3.34766C7.69238 3.34766 7.45312 3.58691 7.45312 3.8877V7.83203H4.54102C4.2334 7.83203 4.00098 8.06445 4.00098 8.37207C4.00098 8.67285 4.2334 8.91211 4.54102 8.91211Z"></path></svg></span>Last edited</th><td><time>@2024年9月27日 15:14</time></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesMultipleSelect"><path d="M1.91602 4.83789C2.44238 4.83789 2.87305 4.40723 2.87305 3.87402C2.87305 3.34766 2.44238 2.91699 1.91602 2.91699C1.38281 2.91699 0.952148 3.34766 0.952148 3.87402C0.952148 4.40723 1.38281 4.83789 1.91602 4.83789ZM5.1084 4.52344H14.3984C14.7607 4.52344 15.0479 4.23633 15.0479 3.87402C15.0479 3.51172 14.7607 3.22461 14.3984 3.22461H5.1084C4.74609 3.22461 4.45898 3.51172 4.45898 3.87402C4.45898 4.23633 4.74609 4.52344 5.1084 4.52344ZM1.91602 9.03516C2.44238 9.03516 2.87305 8.60449 2.87305 8.07129C2.87305 7.54492 2.44238 7.11426 1.91602 7.11426C1.38281 7.11426 0.952148 7.54492 0.952148 8.07129C0.952148 8.60449 1.38281 9.03516 1.91602 9.03516ZM5.1084 8.7207H14.3984C14.7607 8.7207 15.0479 8.43359 15.0479 8.07129C15.0479 7.70898 14.7607 7.42188 14.3984 7.42188H5.1084C4.74609 7.42188 4.45898 7.70898 4.45898 8.07129C4.45898 8.43359 4.74609 8.7207 5.1084 8.7207ZM1.91602 13.2324C2.44238 13.2324 2.87305 12.8018 2.87305 12.2686C2.87305 11.7422 2.44238 11.3115 1.91602 11.3115C1.38281 11.3115 0.952148 11.7422 0.952148 12.2686C0.952148 12.8018 1.38281 13.2324 1.91602 13.2324ZM5.1084 12.918H14.3984C14.7607 12.918 15.0479 12.6309 15.0479 12.2686C15.0479 11.9062 14.7607 11.6191 14.3984 11.6191H5.1084C4.74609 11.6191 4.45898 11.9062 4.45898 12.2686C4.45898 12.6309 4.74609 12.918 5.1084 12.918Z"></path></svg></span>Tags</th><td><span class="selected-value select-value-color-purple">Post</span></td></tr></tbody></table></header><div class="page-body"><h1 class="">What you&#x27;ll discover</h1><ul class="bulleted-list"><li style="list-style-type:disc">The spectrum of languages, from high abstractions to low machine instructions</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">An deep look at many <mark class="highlight-default"><mark class="highlight-orange_background">translators</mark></mark>, including preprocessors, linkers, and compilers, etc.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Dive into Microsoft&#x27;s ecosystem, with a focus on the Common Language Runtime (CLR)</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">comparisons of key terms: bytecode, binary code, machine code, managed code, and unmanaged code, etc.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">The distinctions between Intermediate Language (IL), Intermediate Representation (IR), and Assembly</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Table concludes that support Just-In-Time (JIT) or Ahead-of-Time (AOT) compilation</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">The relationship between JIT/AOT compilation and static/dynamic typing in programming languages. <mark class="highlight-blue"><strong>Correlation || causation?</strong></mark></li></ul><h1 class="">Languages from High to Low</h1><h3 class="">high-level language</h3><p class="">Usually what we write in</p><h3 class="">assembly language</h3><ul class="bulleted-list"><li style="list-style-type:disc">Human readable</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Some developers write assembly language for optimization</li></ul><h3 class="">machine language</h3><ul class="bulleted-list"><li style="list-style-type:disc">Readable by computers</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Also known as binary language</li></ul><p class="">
</p><p class=""><mark class="highlight-blue"><strong>The term &quot;source code&quot; depends on context; it can refer to high-level language or assembly language.</strong></mark></p><p class="">
</p><h1 class="">Broad Definition of Translators</h1><p class="">Broadly includes all tools capable of <mark class="highlight-red"><strong>form conversion</strong></mark>:</p><ol type="1" class="numbered-list" start="1"><li>preprocessor</li></ol><ol type="1" class="numbered-list" start="2"><li>compiler</li></ol><ol type="1" class="numbered-list" start="3"><li>assembler</li></ol><ol type="1" class="numbered-list" start="4"><li>interpreter</li></ol><h3 class="">compiler</h3><p class="">Not necessarily into an executable file. For example, Java compiles to bytecode for its JVM.</p><h3 class="">Interpreter</h3><p class="">Unlike a compiler, it reads and executes simultaneously without creating an executable file.</p><blockquote class="">An Interpreter directly executes instructions written in a programming or scripting language without previously converting them to an object code or machine code.</blockquote><h3 class="">assembler</h3><p class="">assembly language to machine language</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">Preprocessor → Compiler → Assembler → Linker</h1><h3 class="">Tools and Their Associated Languages</h3><ul class="bulleted-list"><li style="list-style-type:disc">Pre-processor: Handles preprocessing directives like <ul class="bulleted-list"><li style="list-style-type:circle">#include</li></ul><ul class="bulleted-list"><li style="list-style-type:circle">#define. </li></ul><ul class="bulleted-list"><li style="list-style-type:circle">a MUST for C, C++</li></ul></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Compiler: Converts preprocessed code to assembly language. Needed for most compiled languages.<ol type="1" class="numbered-list" start="1"><li>GCC for C, C++</li></ol><ol type="1" class="numbered-list" start="2"><li>rustc for Rust<ol type="a" class="numbered-list" start="1"><li>Rust to IR to Assembly</li></ol></li></ol><ol type="1" class="numbered-list" start="3"><li>javac for Java</li></ol><ol type="1" class="numbered-list" start="4"><li>MSVC for C, C++ (windows platform)</li></ol></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Assembler: Converts assembly code to object files. Low-level languages like assembly start here.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Linker: Links multiple object files and libraries into an executable file.</li></ul><h3 class="">Required Tools for Each Programming Language</h3><p class="">tools that Language requires:</p><ul class="bulleted-list"><li style="list-style-type:disc">C/C++: Needs all four</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Java: Compiler converts source to bytecode, <mark class="highlight-red">doesn&#x27;t need assembler and linker</mark><ol type="1" class="numbered-list" start="1"><li>Java Source Code</li></ol><ol type="1" class="numbered-list" start="2"><li> Java Compiler<p class="">turn .java into .class</p></li></ol><ol type="1" class="numbered-list" start="3"><li>Java Bytecode</li></ol><ol type="1" class="numbered-list" start="4"><li>JVM (Class Loader → Bytecode Verifier → Interpreter/JIT Compiler) execution<p class=""><strong>turn .class into machine code</strong></p></li></ol><ol type="1" class="numbered-list" start="5"><li>Machine Code</li></ol></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Python: Usually only needs an interpreter, not the above tools<ul class="bulleted-list"><li style="list-style-type:circle">The most common is <mark class="highlight-red"><strong>CPython, which is implemented in C. </strong></mark>There are other implementations, such as Jython (Java) and IronPython (.NET)</li></ul><p class="">
</p><p class="">Parsing (to AST), then AST to Bytecode (implicit step), then start interpretation(execution)</p></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Assembly: Starts from assembler, doesn&#x27;t need pre-processor and compiler<p class="">Your assembly code assembling, linking, loading then execution</p></li></ul><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">Interpreted Languages and Tools</h1><p class="">Directly translates and executes source code step by step.</p><p class="">Examples: Python, Ruby, PHP, Perl, Lua</p><p class="">JavaScript engines use JIT technology (v8 engine)</p><h3 class="">Usually don&#x27;t need preprocessors or assemblers… but may have preprocessor-like concepts (macro expansion):</h3><ul class="bulleted-list"><li style="list-style-type:disc">Python: Module imports, decorators</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Ruby: Module imports, metaprogramming mechanisms</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">JavaScript: Module imports (ES6+), transpilers like Babel</li></ul><h3 class="">We don&#x27;t need to know exactly how this works, but the underlying mechanisms do have functions similar to an assembler:</h3><ul class="bulleted-list"><li style="list-style-type:disc">Virtual Machines:  use VM to execute code.<ul class="bulleted-list"><li style="list-style-type:circle">CPython: Python uses the Python Virtual Machine (PVM)</li></ul><ul class="bulleted-list"><li style="list-style-type:circle">Java uses the Java Virtual Machine (JVM).</li></ul><p class=""><strong>These virtual machines may internally use Assembly Language to implement certain functionalities or optimizations.</strong></p></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">JIT Compilation: Some interpreters use JIT compilation techniques to compile frequently used code segments into machine code. This process may involve optimizations at the Assembly Language level.<br/>e.g., Modern JavaScript engines use JIT compilation, compiling hot spots of code into machine code at runtime.<br/></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Bytecode: Many interpreted languages first compile source code into bytecode. The VM then interprets and executes this bytecode. Can be viewed as a high-level form of Assembly Language.<br/>e.g., Python primarily uses an interpreter for execution, but it compiles source code into bytecode (.pyc files) to improve execution efficiency.<br/></li></ul><h3 class="">Which role in translators is JIT technology closest to?</h3><p class="">Compiler, as it only compiles the parts that need to be executed.</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">CIL and CLR in the Microsoft Ecosystem</h1><p class="">Let’s discuss CIL and CLR here.</p><figure class="image" style="text-align:left"><a href="https://stackify.com/wp-content/uploads/2018/01/c-users-barry-appdata-local-microsoft-windows-ine-13-1024x550.png"><img style="width:576px" src="https://stackify.com/wp-content/uploads/2018/01/c-users-barry-appdata-local-microsoft-windows-ine-13-1024x550.png"/></a></figure><p class="">
</p><h3 class="">CIL (MSIL)</h3><p class="">C# and VB.NET use the .NET Platform Compiler, also known as <strong>Roslyn</strong>, to translate into usable IL at runtime</p><p class="">
</p><p class=""><strong>CIL (MSIL) is divided into two categories: .DLL &amp; .EXE, including metadata information</strong></p><p class="">DLL v.s. EXE: <mark class="highlight-red"><strong>DLLs require a host EXE, while EXEs are independent processes</strong></mark></p><ul class="bulleted-list"><li style="list-style-type:disc">EXE: An independent program with its own address space, aimed at executing applications</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">DLL: Requires a host, mainly prepares methods/classes for use by other applications, Microsoft&#x27;s implementation of shared libraries.</li></ul><p class=""><strong>Assembly not only just includes CIL, but also:</strong><div class="indented"><ul class="bulleted-list"><li style="list-style-type:disc">Type Information</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Security Information</li></ul></div></p><p class="">
</p><p class=""><strong>Is CIL considered Assembly Language?</strong></p><ol type="1" class="numbered-list" start="1"><li>CIL is higher-level (more readable, more abstract)</li></ol><ol type="1" class="numbered-list" start="2"><li>CIL is platform-independent (not targeting specific platforms or hardware architectures, cross-platform execution)<p class="">But Assembly Language <mark class="highlight-red"><strong>targets specific processors</strong></mark></p></li></ol><ol type="1" class="numbered-list" start="3"><li>Both are <mark class="highlight-orange_background">intermediate states</mark> on the way to machine code</li></ol><p class=""><strong>Can CIL be considered closer to bytecode?</strong></p><p class="">Both CIL and bytecode are IRs, both are used by virtual machines, both use JIT, so it can be said that:</p><p class="">CIL is an intermediate language that combines some features of assembly language (human-readable, low-level) and bytecode (platform-independent, designed for virtual machines). It plays a role in the .NET ecosystem similar to Java bytecode in the Java ecosystem.</p><p class="">
</p><h3 class="">CLR (Rumtime)</h3><p class="">CIL (byte code) is eventually executed as machine code on the CLR: IL is used by the CLR (Common Language <strong>Runtime</strong>), translated into machine-readable machine code through the CLR&#x27;s JIT Compiler, and the CLR also manages the translated native code (in memory).</p><p class="">
</p><p class="">NGEN: .NET also provides the Native Image Generator (NGEN) tool, which can pre-compile CIL into native code to reduce JIT compilation overhead.</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">Java: Bytecode vs. Binary Code</h1><p class="">In the Java ecosystem, bytecode is typically translated into machine code by the Java Interpreter.</p><p class="">Outside the Java world, bytecode and binary code have distinctly different meanings.</p><p class=""><mark class="highlight-red"><strong>For the JVM, bytecode is its binary code.</strong></mark> As long as a system has a JVM, it can run compiled bytecode. This is why bytecode is often considered binary code in the Java context.</p><p class="">Note: The term &quot;Java interpreter&quot; often refers to the interpretation component within the JVM, not a separate tool that directly converts source code to bytecode.</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">Bytecode vs.<br/>Assembly Language vs.<br/>Object Code<br/></h1><blockquote class="">all are intermediate states</blockquote><h3 class="">Bytecode vs. Assembly Language</h3><p class=""><mark class="highlight-red"><strong>Both</strong></mark> bytecode and assembly language <mark class="highlight-red"><strong>are considered Intermediate Representations (IR)</strong></mark> that fall between source code and machine code. However, they have a big difference:</p><ul class="bulleted-list"><li style="list-style-type:disc">Bytecode is for software <strong>interpretation/execution</strong> (e.g., by virtual machines)</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Assembly language is created for hardware <strong>execution</strong> (e.g., by CPUs)<blockquote class="">The main distinction is that bytecode is generated for a virtual machine (software), <br/>while assembly language is created for a CPU (hardware).<br/></blockquote></li></ul><h3 class="">Object Code</h3><p class="">Object code can be thought of as an intermediate step in the compilation process:</p><ol type="1" class="numbered-list" start="1"><li>Multiple object code files are combined by <strong>a linker to produce machine code</strong></li></ol><ol type="1" class="numbered-list" start="2"><li>The linker uses placeholders and offsets within the object code to connect everything together</li></ol><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">JVM vs. CLR and <br/>CLR Implementations<br/></h1><h3 class="">JVM vs. CLR</h3><p class="">JVM (Java Virtual Machine) and CLR (Common Language Runtime) are similar concepts. Both are runtime environments for executing bytecode.</p><ul class="bulleted-list"><li style="list-style-type:disc">JVM is for Java</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">CLR is for .NET<br/><br/></li></ul><h3 class="">CLR Implementations</h3><p class=""><strong>.NET Framework born in 2002, only works in Windows. </strong>.NET Core born in 2016, for crossplatform.</p><p class="">CLR is a concept with three main implementations:</p><ol type="1" class="numbered-list" start="1"><li><strong>coreCLR</strong>: The runtime for <mark class="highlight-red"><strong>.NET Core</strong></mark></li></ol><ol type="1" class="numbered-list" start="2"><li><strong>.NET Framework’s CLR:</strong><table class="simple-table"><tbody><tr><td class="">.NET Framework Version</td><td class="">CLR version</td></tr><tr><td class="">.NET Framework 4 🔝</td><td class="">4</td></tr><tr><td class="">.NET Framework 3</td><td class="">2</td></tr><tr><td class="">.NET Framework 2</td><td class="">2</td></tr><tr><td class="">.NET Framework 1.1</td><td class="">1.1</td></tr></tbody></table></li></ol><ol type="1" class="numbered-list" start="3"><li><strong>Mono Runtime</strong>: Originally independent, later formed Xamarin, now acquired by Microsoft (Xamarin CLR is based on Mono CLR)<ul class="bulleted-list"><li style="list-style-type:disc">Mono runtime doesn&#x27;t have a specific name</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Unity was based on Mono but is now extending towards lower levels, potentially moving away from Mono</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">For Android, Xamarin converts code to IL (Intermediate Language), then uses Mono runtime&#x27;s JIT Compiler</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">For iOS, it uses AOT (Ahead-Of-Time) compilation, similar to <mark class="highlight-red"><strong>UWP</strong></mark><p class=""><mark class="highlight-red"><strong>(before iOS 14.2, Apple didn’t accept JIT)</strong></mark></p></li></ul></li></ol><h3 class=""><mark class="highlight-red">UWP</mark> is not using JIT, it use AOT</h3><p class="">UWP (Universal Windows Platform) doesn&#x27;t use JIT compilation. In the .NET ecosystem:</p><ul class="bulleted-list"><li style="list-style-type:disc">High-level languages are compiled to IL</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">UWP uses AOT execution, which is separate from JIT</li></ul><p class=""><strong>Additional Note</strong>: .NET Native is a specialized AOT Compiler for UWP</p><table class="simple-table"><tbody><tr><td class="">technologies</td><td class="">mode</td></tr><tr><td class=""><strong>.NET Native</strong></td><td class="">AOT（Ahead-of-Time）</td></tr><tr><td class=""><strong>.NET Framework CLR / CoreCLR / Mono CLR</strong></td><td class="">JIT</td></tr></tbody></table><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">Machine Code vs. Native Code vs.<br/>Managed Code v.s. Unmanaged Code<br/></h1><h3 class="">managed code (have their own env, context to work on)</h3><p class="">C#, VB.NET, Java, which also executed in their own VM (e.g. .NET CLR and JVM). Platforms that understand IL will convert it to machine code</p><p class="">How to remember? &quot;Managed&quot; means it needs extra management, and also provides garbage collection</p><h3 class="">unmanaged code</h3><p class="">C, C++ which are compiled directly into machine code. Programmers need to handle more dirty works.</p><h3 class="">native code</h3><p class="">Native code is compiled for a <mark class="highlight-red"><strong>specific hardware</strong></mark> architecture.</p><h3 class="">machine code</h3><p class=""><mark class="highlight-red"><strong>Broader concept.</strong></mark></p><p class="">If Computer <mark class="highlight-red"><strong>DO UNDERSTAND</strong></mark> the code, then it’s machine code. </p><h3 class="">unmanaged code &amp; native code are interchangeable</h3><p class="">This pair are interchangeable, because they all works directly with hardware.</p><h3 class="">machine code &amp; native code are interchangeable</h3><p class="">This pair can be interchangeable depending on the context, due to their relative nature.<br/>For example, native code is designed to run directly on specific hardware, <br/><mark class="highlight-red"><strong>so from the perspective of that particular environment, it is almost machine code.</strong></mark></p><p class="">Both are the last step for that (context || hardware)</p><p class="">If we&#x27;re just talking about what the computer can understand, we generally call it machine code for all languages when it&#x27;s in a form the computer can understand.</p><p class=""><mark class="highlight-red"><strong>This relative nature of the terms explains why they are sometimes used interchangeably, especially when discussing code execution in a specific hardware environment.</strong></mark></p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">assembly v.s. LLVM IR v.s. IL</h1><h3 class="">First, IR vs. IL</h3><ul class="bulleted-list"><li style="list-style-type:disc">IR (Intermediate Representation)：Typically refers to an internal form used by compilers.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">IL (Intermediate Language)：Usually refers to an intermediate form closer to high-level languages.<br/><br/></li></ul><p class="">However, these terms are often used interchangeably. For example, LLVM uses IR, while .NET uses IL.</p><p class=""><mark class="highlight-blue"><strong>And IL retaining more of the source language&#x27;s structure.</strong></mark></p><p class="">
</p><h3 class="">Assembly vs. LLVM IR</h3><p class="">LLVM IR tends to have more of the original high-level language concept.</p><p class="">Assembly has very clear and specific instructions that closely match the machine&#x27;s architecture.</p><p class="">
</p><p class=""><mark class="highlight-blue"><strong>from high to low: IL &gt; LLVM IR &gt; Assembly &gt; machine code</strong></mark></p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">JIT v.s. AOT</h1><p class="">Just in Time v.s. Ahead of Time</p><h3 class="">for Language-based</h3><p class=""><mark class="highlight-red">JIT</mark>: Like JavaScript, compiles code <mark class="highlight-red"><strong>during execution</strong></mark>.</p><p class=""><mark class="highlight-red">AOT</mark>: Like C, <mark class="highlight-red">compiles all code before running</mark>.</p><h3 class="">for modes: dev v.s. prod</h3><p class="">Production (AOT):</p><ul class="bulleted-list"><li style="list-style-type:disc">Faster, smaller bundle</li></ul><ul class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red">More work for server</mark>, less for client</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Example: vue-loader uses AOT</li></ul><p class="">Development (JIT):</p><ul class="bulleted-list"><li style="list-style-type:disc">Not bundled together, files packaged separately and dynamically</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Easier for development, lighter on CPU, but <mark class="highlight-red">more work for browser</mark></li></ul><h3 class="">mode in Angular</h3><p class="">JIT: </p><p class=""><code>platformBrowserDynamic().bootstrapModule(AppModule)</code></p><p class="">AOT: </p><p class=""><code>plaformBrowser().bootstrapModuleFactory(AppModuleNgFactory)</code></p><p class="">
</p><p class=""><div class="indented"><p class="">
</p></div></p><h1 class="">Static languages equal AOT?</h1><p class="">Many static languages use AOT, but it&#x27;s not a rule</p><p class="">exception: </p><ol type="1" class="numbered-list" start="1"><li>Static languages can use JIT like Java, uses JIT in its VM.</li></ol><ol type="1" class="numbered-list" start="2"><li>Dynamic languages can use AOT like Python&#x27;s Cython.</li></ol><table class="simple-table"><tbody><tr><td class=""><strong>language</strong></td><td class="" style="width:50px"><strong>AOT</strong></td><td class="" style="width:40px"><strong>JIT</strong></td><td class="" style="width:439.9908752441406px"></td></tr><tr><td class="">Java</td><td class="" style="width:50px">✅</td><td class="" style="width:40px">✅</td><td class="" style="width:439.9908752441406px"></td></tr><tr><td class="">C#</td><td class="" style="width:50px">✅</td><td class="" style="width:40px">✅</td><td class="" style="width:439.9908752441406px">JIT by default (.NET CLR)<br/>AOT available (.NET Native)<br/></td></tr><tr><td class="">JavaScript</td><td class="" style="width:50px">✅</td><td class="" style="width:40px">✅</td><td class="" style="width:439.9908752441406px">JIT in browsers, Node.js; AOT with tools like Closure Compiler</td></tr><tr><td class="block-color-teal_background">Vue</td><td class="block-color-teal_background" style="width:50px">✅</td><td class="block-color-teal_background" style="width:40px"></td><td class="block-color-teal_background" style="width:439.9908752441406px"> 1. vue-loader is indeed an AOT<br/> 2. JIT realization: Vue 3 introduced a new feature  which optimizes the rendering process at runtime.<br/></td></tr><tr><td class="block-color-teal_background">Angular</td><td class="block-color-teal_background" style="width:50px">✅</td><td class="block-color-teal_background" style="width:40px">✅</td><td class="block-color-teal_background" style="width:439.9908752441406px"></td></tr><tr><td class="block-color-teal_background">ReactJs</td><td class="block-color-teal_background" style="width:50px"></td><td class="block-color-teal_background" style="width:40px"></td><td class="block-color-teal_background" style="width:439.9908752441406px">depends on ecosystems:<br/> 1. babel, webpack do AOT things<br/> 2. Nextjs SSR similar to AOT<br/></td></tr><tr><td class="">Python</td><td class="" style="width:50px">✅</td><td class="" style="width:40px">✅</td><td class="" style="width:439.9908752441406px">Interpreted by default, JIT with <code>Numba</code> and <code>PyPy</code>, AOT with <code>Cython</code></td></tr><tr><td class="">C/C++</td><td class="" style="width:50px"></td><td class="" style="width:40px">✅</td><td class="" style="width:439.9908752441406px"></td></tr><tr><td class="">Rust</td><td class="" style="width:50px"></td><td class="" style="width:40px">✅</td><td class="" style="width:439.9908752441406px"></td></tr><tr><td class="">Go</td><td class="" style="width:50px"></td><td class="" style="width:40px">✅</td><td class="" style="width:439.9908752441406px"></td></tr></tbody></table><p class="">That’s why Vue’s initial development startup is slow, and it can’t have any errors, whereas React’s JIT will only show errors if you route to a page with errors.</p><h1 class="">Interpreted Languages equals dynamic language?</h1><table class="simple-table"><tbody><tr><td class=""><strong>language</strong></td><td class=""><strong>language kind</strong></td><td class=""><strong>type checking</strong></td></tr><tr><td class="">Python</td><td class="">interpreted</td><td class="">dynamic</td></tr><tr><td class="">JavaScript</td><td class="">interpreted</td><td class="">dynamic</td></tr><tr><td class="">Java</td><td class="">compiled</td><td class="">static</td></tr><tr><td class="">C++</td><td class="">compiled</td><td class="">static</td></tr><tr><td class="block-color-orange_background">Exception</td><td class="block-color-orange_background"></td><td class="block-color-orange_background"></td></tr><tr><td class="">Haskell, OCaml</td><td class="">Interpreted</td><td class="">static</td></tr><tr><td class="">Erlang</td><td class="">compiled</td><td class="">dynamic</td></tr></tbody></table><p class=""><mark class="highlight-blue"><strong>Correlation is not causation.</strong></mark></p><p class="">
</p><h1 class="">Big Thank to these resources</h1><p class=""><a href="https://www.spreered.com/compiler_for_dummies/">https://www.spreered.com/compiler_for_dummies/</a></p><p class=""><a href="https://stackoverflow.com/questions/1210873/difference-between-dll-and-exe">https://stackoverflow.com/questions/1210873/difference-between-dll-and-exe</a></p><p class=""><a href="https://stackoverflow.com/questions/11701063/is-cil-an-assembly-language-and-jit-an-assembler">https://stackoverflow.com/questions/11701063/is-cil-an-assembly-language-and-jit-an-assembler</a></p><p class=""><a href="https://www.geeksforgeeks.org/difference-between-byte-code-and-machine-code/">https://www.geeksforgeeks.org/difference-between-byte-code-and-machine-code/</a></p><p class=""><a href="https://techterms.com/definition/bytecode">https://techterms.com/definition/bytecode</a></p><p class=""><a href="https://stackoverflow.com/questions/466790/assembly-code-vs-machine-code-vs-object-code">https://stackoverflow.com/questions/466790/assembly-code-vs-machine-code-vs-object-code</a></p><p class=""><a href="https://www.geeksforgeeks.org/language-processors-assembler-compiler-and-interpreter/">https://www.geeksforgeeks.org/language-processors-assembler-compiler-and-interpreter/</a></p><p class="">JVM, CLR</p><p class=""><a href="https://pediaa.com/what-is-the-difference-between-jvm-and-clr/">https://pediaa.com/what-is-the-difference-between-jvm-and-clr/</a></p><p class=""><a href="https://stackify.com/net-ecosystem-runtime-tools-languages/">https://stackify.com/net-ecosystem-runtime-tools-languages/</a></p><p class=""><a href="https://blog.csdn.net/yinfourever/article/details/108258319">https://blog.csdn.net/yinfourever/article/details/108258319</a></p><p class=""><a href="https://stackoverflow.com/questions/34987202/net-framework-net-core-net-native-dnx-core-clr-cil-pcl-simple-explain">https://stackoverflow.com/questions/34987202/net-framework-net-core-net-native-dnx-core-clr-cil-pcl-simple-explain</a></p><p class="">
</p><p class=""><a href="https://www.vskills.in/certification/tutorial/net-technology-framework-and-common-language-runtimeclr/">https://www.vskills.in/certification/tutorial/net-technology-framework-and-common-language-runtimeclr/</a></p><p class=""><a href="https://niraj-vishwakarma.medium.com/how-unity-supports-cross-platform-feature-ae722321cfa">https://niraj-vishwakarma.medium.com/how-unity-supports-cross-platform-feature-ae722321cfa</a></p><p class=""><a href="https://stackoverflow.com/questions/3434202/what-is-the-difference-between-native-code-machine-code-and-assembly-code">https://stackoverflow.com/questions/3434202/what-is-the-difference-between-native-code-machine-code-and-assembly-code</a></p><p class="">
</p><p class="">Angular</p><p class=""><a href="https://levelup.gitconnected.com/just-in-time-jit-and-ahead-of-time-aot-compilation-in-angular-8529f1d6fa9d">https://levelup.gitconnected.com/just-in-time-jit-and-ahead-of-time-aot-compilation-in-angular-8529f1d6fa9d</a></p><p class=""><a href="https://medium.com/@Sujithnath/angular-aot-vs-jit-comparison-ce1d96ede491">https://medium.com/@Sujithnath/angular-aot-vs-jit-comparison-ce1d96ede491</a></p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body>